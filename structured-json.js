var StructuredJSON=function(e){"use strict";var r=Uint8Array,t=(e,r,t=[])=>{for(;e<=r;)t.push(e++);return t},n=[...t(65,90),...t(97,122),...t(48,57),45,95,61],s=[...Array(43).fill(0),62,0,62,0,63,...t(52,61),0,0,0,64,0,0,0,...t(0,25),0,0,0,0,63,0,...t(26,51),0,0];const c="object"==typeof self?self:globalThis,o=Reflect.getPrototypeOf(Uint8Array),a=(e,t)=>{const n=(r,t)=>(e.set(t,r),r),a=u=>{if(e.has(u))return e.get(u);const[f,i,l,g]=t[u];switch(f){case 0:case-1:return n(i,u);case 9:{const e=function(e){for(var t=e.charCodeAt.bind(e),n=e.length,c="="===e[n-2]?2:"="===e[n-1]?1:0,o=new r((.75*e.length+.5|0)-c),a=0,u=n-c&4294967292,f=0;f<u;f+=4)n=s[t(f)]<<18|s[t(f+1)]<<12|s[t(f+2)]<<6|s[t(f+3)],o[a++]=n>>16&255,o[a++]=n>>8&255,o[a++]=255&n;return 1===c&&(n=s[t(f)]<<10|s[t(f+1)]<<4|s[t(f+2)]>>2,o[a++]=n>>8&255,o[a++]=255&n),2===c&&(n=s[t(f)]<<2|s[t(f+1)]>>4,o[a++]=255&n),console.log(o),o}(a(i)).buffer;return n(e,u)}case 1:{const e=n([],u);for(const r of i)e.push(a(r));return e}case 2:{const e=n({},u);for(const[r,t]of i)e[a(r)]=a(t);return e}case 3:return n(new Date(i),u);case 4:{const{source:e,flags:r}=i;return n(new RegExp(e,r),u)}case 5:{const e=n(new Map,u);for(const[r,t]of i)e.set(a(r),a(t));return e}case 6:{const e=n(new Set,u);for(const r of i)e.add(a(r));return e}case 7:{const{name:e,message:r}=i;return n(new c[e](r),u)}case 8:return n(BigInt(i),u);case"BigInt":return n(Object(BigInt(i)),u)}if(Reflect.getPrototypeOf(c[f])===o){const e=a(i);return n(new c[f](e,l,g),u)}return n(new c[f](i),u)};return a},u="",{toString:f}={},{keys:i}=Object,l=e=>{const r=typeof e;if("object"!==r||!e)return[0,r];const t=f.call(e).slice(8,-1);switch(t){case"Array":return[1,u];case"Object":return[2,u];case"Date":return[3,u];case"RegExp":return[4,u];case"Map":return[5,u];case"Set":return[6,u];case"ArrayBuffer":return[9,u]}return t.includes("Array")?[1,t]:t.includes("Error")?[7,t]:[2,t]},g=([e,r])=>0===e&&("function"===r||"symbol"===r),h=(e,t,s,c)=>{const o=(e,r)=>{const t=c.push(e)-1;return s.set(r,t),t},a=c=>{if(s.has(c))return s.get(c);let[u,f]=l(c);switch(u){case 0:{let r=c;switch(f){case"bigint":u=8,r=c.toString();break;case"function":case"symbol":if(e)throw new TypeError("unable to serialize "+f);r=null;break;case"undefined":return o([-1],c)}return o([u,r],c)}case 9:{const e=(e=>{for(var t=-1,s=e.length,c=new r(Math.ceil(4*s/3)),o=0;++t<s;){var a=e[t],u=e[++t];c[o++]=n[a>>2],c[o++]=n[(3&a)<<4|u>>4],isNaN(u)?(c[o++]=n[64],c[o++]=n[64]):(a=e[++t],c[o++]=n[(15&u)<<2|a>>6],c[o++]=n[isNaN(a)?64:63&a])}const f=(new TextDecoder).decode(c);return f+(f.length%3==2?"=":f.length%3==1?"==":"")})(new Uint8Array(c));return o([u,a(e)],c)}case 1:{if(f){const e=[f,,c.byteOffset,c.byteLength/c.BYTES_PER_ELEMENT],r=o(e,c);return e[1]=a(c.buffer),r}const e=[],r=o([u,e],c);for(const r of c)e.push(a(r));return r}case 2:{if(f)switch(f){case"BigInt":return o([f,c.toString()],c);case"Boolean":case"Number":case"String":return o([f,c.valueOf()],c)}if(t&&"toJSON"in c)return a(c.toJSON());const r=[],n=o([u,r],c);for(const t of i(c))!e&&g(l(c[t]))||r.push([a(t),a(c[t])]);return n}case 3:return o([u,c.toISOString()],c);case 4:{const{source:e,flags:r}=c;return o([u,{source:e,flags:r}],c)}case 5:{const r=[],t=o([u,r],c);for(const[t,n]of c)(e||!g(l(t))&&!g(l(n)))&&r.push([a(t),a(n)]);return t}case 6:{const r=[],t=o([u,r],c);for(const t of c)!e&&g(l(t))||r.push(a(t));return t}}const{message:h}=c;return o([u,{name:f,message:h}],c)};return a},{parse:y,stringify:p}=JSON,w={json:!0,lossy:!0};return e.parse=e=>{return r=y(e),a(new Map,r)(0);var r},e.stringify=e=>p(((e,{json:r,lossy:t}={})=>{const n=[];return h(!(r||t),!!r,new Map,n)(e),n})(e,w)),e}({});
